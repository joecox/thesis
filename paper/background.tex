\chapter{Background and Prior Work}
This paper builds on a number of existing tools and prior work done by the author and others. In this chapter we describe the existing tools in greater detail and how they were modified or supplemented to support the analysis in the paper. First, we expand on the technical details of Phosphor. Second, we describe details of Petablox, including its architecture and Datalog fact engine. We also describe prior work on partial instrumentation in greater detail to help elucidate the differences between the analysis in that prior work and the analysis in this paper.
\section{Phosphor}
Phosphor \cite{phosphor_oopsla} is a general purpose taint tracking tool

taint tag info

example tag propagation

native

source and sinks

jdk stuff, eval
\section{Petablox}
Petablox \cite{petablox} is a large-scale program analysis tool developed at Georgia Tech. Petablox is capable of running analyses such as deadlock analysis, datarace analysis, and k-cfa object sensitive and insensitive analyses on very large codebases.

Petablox uses Datalog \cite{datalog} to generate program analysis facts from other program facts. Datalog is a logic programming language and a strict subset of Prolog. Statements in Datalog take on the form \texttt{x(t) :- y(t), z(t).}, where the predicate being defined on the left hand side is a logical conjunction of the predicates on the right hand side.

Internally, Petablox uses the Soot bytecode optimization framework \cite{vallee1999soot} to produce a higher level representation (namely Jimple or Baf) of the program bytecode. Petablox then translates that representation into Datalog program facts. Petablox maintains a number of program entity domains, including domains of methods, local variables, fields, and more. These domains are populated with all of the relevant entities generated by Soot. Domains are typically labeled with a single letter in Petablox. For example, domain M represents the domain of all methods in the program.

Petablox also computes a number of relations on top of the domains. These relations come in two basic types:

\begin{itemize}
  \item Relations which add a level of specificity to a domain and create a subset of the domain. An example would be a relation consisting of all fields that are declared final.
  \item Relations which relate two or more different domains.
\end{itemize}

The second kind of relation is the most common. An example would be the \texttt{MmethArg} relation, which relates methods, the local variables which represent the arguments to the method, and the position of those variables in the argument list. This relation allows one to query if a local variable is the same variable as a positional argument. The components of the relation are restricted to certain predefined domains. The method must be in the method domain, the local variable must be in the domain of local variables, and the position must appear in the domain of integer argument positions. This gives Petablox relations a certain aspect of typing and prevents the addition of any facts that do not have the correct type or do not appear in the associated domain. The existence of facts in domains cannot be modified by relations, as domains are populated once and are constant thereafter. 

Some relations are defined using Java and some are defined directly in Datalog. The relations defined in Java are typically those that are easier to create with access to Soot types and utilities. Relations defined directly in Datalog are typically those that are logically abstract and are components of an analysis. Predicates defined in Java are computed simply by running the definition code after the program domains have been populated. However, computing predicates defined in Datalog requires a Datalog engine to run the Datalog code. Petablox offers compatibility with two such engines: bddbddb \cite{bddbddb} and the proprietary Logicblox database \cite{logicblox}. Logicblox runs on a modified form of Datalog called LogiQL, so Petablox includes tools to convert Datalog code to LogiQL code for use with Logicblox.

Unlike other program analysis tools, the scope of what Petablox analyzes is tightly related to the reachability of the analyzed program. Petablox will compute method reachability, either statically or dynamically based on configuration, and only analyze program entities residing within reachable methods. This makes many analyses much easier because they often are only concerned with behavior of reachable program points, and Petablox gives this for free.

Originally, Petablox used a different Datalog schema to represent programs. Petablox used the Doop pointer analysis framework \cite{doop}, which came with its own set of Datalog predicates to represent a Java program. During the development effort for this paper, Petablox switched to the new Datalog schema which has been discussed up to this point. This posed a significant hurdle, given that the two schema were built upon completely different architectures. Doop did not have any concept of domains and did not consider reachability, instead including all entities in a program.  

However, the new schema certainly has limitations compared to Doop. First, the new schema does not include primitive-typed variables in the domain of local variables. As such, none of the relations using local variables include any primitives. There is also no domain of constant values, so those program entities are not represented. The new schema also does not have a relation listing native methods in the program. Instead, they choose a select few native methods and simulate the bodies of those methods so that analyses can model the behavior of calls to native code. However, all other native methods are anonymized and simply become stubbed methods without any concrete body.
\section{Partial Instrumentation}
Don't have to instrument everything if data doesn't touch everything

Callgraph

Callgraph intersection

Special cases

Modification of phosphor

limitations: native

This subset of methods is generated by calculating a callgraph intersection. The callgraph of a program is produced statically and the set of methods on the outward callgraphs from each source method is intersected with the set of methods on the inwards callgraphs into each sink method. This approach is able to achieve 

