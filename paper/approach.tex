\chapter{Approach and Implementation}
In this chapter we describe the approach taken for our analysis. We
show how the analysis propagates taint through the program and how
this more accurately models the behavior of \phosphor{} than previous
work. The analysis is constructed as a series of Datalog program facts
which build on both existing facts and each other. Each program fact
is implied by a logical conjunction of one or more program facts. We
begin with the facts that describe taintedness in local variables and
fields. We then describe facts that are concerned with how taint is
propagated through native library calls. We then describe facts that
determine which methods need to be tracked. We finally describe facts
about which call sites of tracked methods will call instrumented
versions of the callee and which will call uninstrumented versions. We
also detail additions and modifications to Petablox that were required
to enable the analysis.

To elucidate the how the Datalog rules apply to a Java program and how
data flow facts are deduced, a code example is provided in section
\ref{ex}, along with a program fact base, relevant rules from the
following sections, and a solution to the rules.

Underscore characters in the Datalog rules represent arguments which
may resolve to any entity in the relevant entity domain. For example,
an underscore character given as an argument for a type domain can
resolve to \texttt{int}, \texttt{java.lang.String}, or any other type.

\section{Tainted and Untainted Objects}
\subsection{Taint Predicates}
We begin by describing the predicates that represent tainted and
untainted values. \texttt{taintedX} and \texttt{untaintedX} represent
tainted and untainted local variables, respectively. The local
variables can be of primitive or reference type. If a local variable
appears in \texttt{taintedX}, then the variable contained tainted data
at some point. The same is true of a variable appearing in
\texttt{untaintedX}. We are not interested in whether a variable
\textit{ever} contains tainted or untainted data, but rather if it
\textit{always} contains tainted or untainted data. If the latter is
true, then we do not have to track the data through a method, since we
know that it will be tainted at the end if it is tainted at the
beginning.

For this insight to work, we must make a fundamental simplification of
how taint is tagged and tracked through the program. Originally,
\phosphor{} maintained a 32-bit taint tag which described exactly how
a variable had been tainted and the origin of its taint. If we do not
plan to track taint propagation through some methods in which a
variable is always tainted or always untainted, we must simplify the
taint tag to be only a boolean value. The reason for this is that a
variable may be always tainted in a method, but the exact details of
its taint may change through that method. The 32-bit taint tag may
change from one non-zero taint tag to another. Without tracking taint
propagation through that method, we are not able to track that
change. The most we can know is if a variable is tainted at the
beginning of a method and it is always tainted during the method, it
will be tainted at the end of the method.

The predicates \texttt{taintedF} and \texttt{untaintedF} represent
tainted and untainted fields in the same manner as local variables.
\subsection{TaintSrc and TaintSink Predicates}
The predicates \texttt{taintSrc} and \texttt{taintSink} represent the
methods that appear in the source and sink files passed to
\phosphor{}. These are the methods that \phosphor{} tracks data from
and to.

The predicates are implemented in Java as an addition the Petablox
tool. The source and sink files can be passed to Petablox with a new
configuration option and are read and filled into the
\texttt{taintSrc} and \texttt{taintSink} predicates.
\subsection{Assignment Rules}
The following are the Datalog rules to handle propagation of taint by
way of assignment:
\begin{equation}
  \mathtt{taintedX(x) \is taintedX(y) \also MXVarAsgnInst(\_,x,y).}
\end{equation}
\begin{equation}
  \mathtt{untaintedX(x) \is untaintedX(y) \also
    MXVarAsgnInst(\_,x,y).}
\end{equation}
\begin{equation}
  \mathtt{taintedF(f) \is MputFldInstX(f,x) \also taintedX(x).}
\end{equation}
\begin{equation}
  \mathtt{untaintedF(f) \is MputFldInstX(f,x) \also untaintedX(x).}
\end{equation}
\begin{equation}
  \mathtt{taintedX(x) \is MgetFldInstX(x,f) \also taintedF(f).}
\end{equation}
\begin{equation}
  \mathtt{untaintedX(x) \is MgetFldInstX(x,f) \also untaintedF(f).}
\end{equation}

The \texttt{MXVarAsgnInst} predicate is part of Petablox's program
representation schema. \texttt{MXVarAsgnInst(m,x,y)} represents a
statement of the form $x = y$ within the scope of method $m$. Rules
3.1 and 3.2 represent the propagation of taint from a local variable
into another by way of assignment. Rule 3.1 states that if the right
hand side is tainted, the left hand side will be tainted as well. Rule
3.2 states the same for untainted propagation.

Rules 3.3 and 3.4 represent taint propagation of local variables being
assigned to fields. The \texttt{MputFldInstX} predicate is an
abstraction over both instance and static field stores and represents
statements of either the form $b.x = y$ or $ClassName.x = y$. Rule 3.3
states that if the right hand side is tainted, the field will be
tainted as well. Rule 3.4 states the same but for untainted
propagation.

Rules 3.5 and 3.6 represent taint propagation of fields being assigned
to local variables. The \texttt{MgetFldInstX} predicate is an
abstraction over instance and static field loads, similar to
\texttt{MputFldInstX} from before, and represents statements of either
the form $x = b.y$ or $x = ClassName.y$. Rule 3.5 states that if the
field is tainted, the local variable will also be tainted. Rule 3.6
states the same but for untainted propagation.

Statements of the form $b.x = c.y$ where a field is loaded and then
stored into a field do not need to be explicitly modeled, since under
the covers the field is first loaded into a local variable, which is
handled by Rules 3.5 and 3.6, and then the local variable is stored
into the left hand side field, which is handled by Rules 3.3 and 3.4.
\subsection{Return Rules}
The following are the Datalog rules to handle propagation of taint
through returns.
\begin{equation}
  \mathtt{taintedX(x) \is IinvkXRet(i,z,x) \also IM(i,m) \also
    MmethXRet(m,z,y) \also taintedX(y).}
\end{equation}
\begin{equation}
  \begin{split}
    \mathtt{untaintedX(x) \is} & \mathtt{IinvkXRet(i,z,x) \also
      IM(i,m) \also MmethXRet(m,z,y) \also} \\ & \mathtt{
      untaintedX(y) \also !taintSrc(m).} \\
  \end{split}
\end{equation}
\begin{equation}
  \mathtt{taintedX(x) \is taintSrc(m) \also IinvkXRet(i,\_,x) \also
    IM(i,m).}
\end{equation}

Rules 3.7 and 3.8 model the taint propagation of the return of local
variables in callee methods into local variables of caller methods.

The \texttt{IinvkXRet} predicate relates invocation sites to local
variables the invocation returns into. \texttt{IinvkXRet(i,z,x)} means
that the $z$th return variable of call site $i$ is stored into local
variable $x$. The \texttt{IM} relation relates invocations to their
resolved methods. \texttt{IM(i,m)} means that method $m$ is the
resolved method of call site $i$. The \texttt{MmethXRet} predicate
relates methods and their return variables. \texttt{MmethXRet(m,z,x)}
means that local variable $x$ is the $z$th return of method $m$.

Rule 3.7 states that when the $z$th return variable of the method $m$
is tainted, the local variable $x$ receiving the $z$th return of
invocation site $i$ will be tainted.

Rule 3.8 states the same as 3.7 but for the propagation of untainted
data, with one exception. If $m$ is a source method, then the return
variable should be tainted regardless of the content of $m$. Therefore
we add an extra check to Rule 3.8 that $m$ is not a source method.

Rule 3.9 represents the flow of tainted data from source methods into
local variables. It states that if method $m$ is a source method, and
invocation site $i$ resolves to $m$, then any local variable being
assigned a return value from $m$ is tainted.
\subsection{Argument Rules}
The following are the Datalog rules to handle propagation of taint
through variables passed as arguments.
\begin{equation}
  \mathtt{taintedX(x) \is MmethXArg(m,z,x) \also IM(i,m) \also
    IinvkXArg(i,z,y) \also taintedX(y).}
\end{equation}
\begin{equation}
  \begin{split}
    \mathtt{untaintedX(x) \is} & \mathtt{MmethXArg(m,z,x) \also
      IM(i,m) \also IinvkXArg(i,z,y) \also} \\ &
    \mathtt{untaintedX(y).} \\
  \end{split}
\end{equation}

Rules 3.10 and 3.11 model the taint propagation of arguments passed
into invocation sites to the local variables representing the
parameters of a method.

The \texttt{MmethXArg} predicate relates methods and their
parameters. \\ \texttt{MmethXArg(m,z,x)} means that local variable $x$
is the $z$th parameter of method $m$. The \texttt{IinvkXArg} predicate
relates local variable arguments and method invocation
sites. \texttt{IinvkXArg(i,z,x)} means that local variable $x$ is the
$z$th argument passed into the method represented by invocation $i$ at
invocation site $i$.

Rule 3.10 states that when the $z$th argument is tainted, the $z$th
parameter of method $m$ will be tainted. Rule 3.11 states the same but
for the propagation of untainted data.
\subsection{Constants and New Object Rules}
Constants and new object allocation statements are untainted by
definition, given that they did not originate from source methods. The
following are the Datalog rules to ensure that local variables and
fields that have been assigned constant values and newly allocated
objects are marked as untainted.
\begin{equation}
  \mathtt{untaintedX(x) \is MXAsgnConst(\_,x,\_).}
\end{equation}
\begin{equation}
  \mathtt{untaintedF(f) \is MputFldInstConst(f,\_).}
\end{equation}
\begin{equation}
  \mathtt{untaintedX(x) \is XV(x,v) \also MobjValAsgnInst(\_,v,\_).}
\end{equation}
\begin{equation}
  \mathtt{untaintedX(x) \is MmethXArg(m,z,x) \also IM(i,m) \also
    IinvkConstArg(i,z,\_).}
\end{equation}

Rule 3.12 marks local variables on the left hand sides of statements
like $x = 5$ as untainted. The \texttt{MXAsgnConst} predicate
represents those statements. \texttt{MXAsgnConst(m,x,c)} means that
constant $c$ is assigned to local variable $x$ in method $m$. We want
these local variables to be marked as untainted regardless of the
constant or method, so we use underscores as the method and constant
arguments.

Rule 3.13 does the same as 3.12 but for fields. The
\texttt{MputFldInstConst} predicate models stores of constants into
fields, such as statements of the form $b.x = 5$. Again we mark the
field $f$ as untainted regardless of the constant.

Rule 3.14 marks local variables that are assigned objects from object
allocation statements such as the form $x = new A()$ as untainted. The
\texttt{MobjValAsgnInst} predicate represents such object allocation
statements. \texttt{MobjValAsgnInst(m,v,h)} means that object
allocation statement $h$ assigns to local variable $v$ inside method
$m$. In this predicate, the local variable belongs to a different
entity domain that previous local variables. Petablox includes a
domain V which represents all local variables of reference
type. Because all object allocation statements create objects of
reference type, the predicate uses domain V. To add the correct local
variable in the domain of all local variables to the
\texttt{untaintedX} predicate, we use the \texttt{XV} predicate, which
relates identical objects between the reference type variable and all
variable domains.

Rule 3.15 marks local variable parameters of methods as untainted if a
constant was passed into the invocation. The predicate
\texttt{IinvkConstArg} represents any constant passed into a method
invocation.

No rule is required to model the passing of an object allocation
statement into a method invocation. The object allocation is first
placed into a local variable, which is modeled by Rule 3.14, and then
passes the local variable into the invocation, which is modeled by
Rules 3.10 and 3.11.
\section{Native Code}
The following are the Datalog rules to model taint propagation of
taint across native call boundaries.
\begin{equation}
  \begin{split}
    \mathtt{taintedX(x) \is} & \mathtt{MmethXRet(m,z,x) \also
      nativeM(m) \also IM(i,m) \also} \\ & \mathtt{IinvkXArg(i,z,y)
      \also taintedX(y).} \\
  \end{split}
\end{equation}
\begin{equation}
  \mathtt{untaintedX(x) \is MmethXRet(m,\_,x) \also nativeM(m) \also
    !taintedX(x).}
\end{equation}

Rules 3.16 and 3.17 represent the taint propagation across native call
boundaries for native calls which return a value. The \texttt{nativeM}
predicate is a subset of the method domain and represents all methods
that have the native modifier. Rule 3.16 states that the return of a
native method is tainted if there exists any argument passed to the
method that is tainted. Rule 3.17 states that any returns from native
methods that have not been marked tainted are untainted. This captures
the situations where none of the arguments to a native method are
tainted.
\begin{equation}
  \begin{split}
    \mathtt{taintedX(x) \is} & \mathtt{arraycopyM(m) \also IM(i,m)
      \also IinvkXArg(i,1,y) \also} \\ & \mathtt{IinvkXArg(i,3,x)
      \also taintedX(y).} \\
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    \mathtt{untaintedX(x) \is} & \mathtt{arraycopyM(m) \also IM(i,m)
      \also IinvkXArg(i,1,y) \also} \\ & \mathtt{IinvkXArg(i,3,x)
      \also untaintedX(y).} \\
  \end{split}
\end{equation}

Rules 3.18 and 3.19 represent the taint propagation across native call
boundaries specifically for \texttt{System.arraycopy}. This is a void
native method that performs a shallow copy of its \texttt{src}
argument into the object provided as the \texttt{dest} argument. The
\texttt{arraycopyM} predicate represents only one method,
\texttt{System.arraycopy}. Rule 3.18 states that if the argument at
index 1 (the \texttt{this} object is at index 0), which is the source
array, is tainted, then the argument at index 3, which is the
destination array, is also tainted. Rule 3.19 states the same but for
propagation of untainted data.
\section{Tracked and Untracked Methods}
The following are the Datalog rules that govern which methods are
tracked and which are untracked.
\begin{equation}
  \mathtt{tracked(m) \is MM(m,n) \also taintSink(n).}
\end{equation}
\begin{equation}
  \mathtt{tracked(m) \is MX(m,x) \also taintedX(x) \also
    untaintedX(x).}
\end{equation}
\begin{equation}
  \mathtt{untracked(m) \is !tracked(m).}
\end{equation}


Rules 3.20 and 3.21 model which methods should be tracked and Rule
3.22 models which methods should be untracked. Rule 3.20 states that
any method $m$ which calls a method $n$ should be tracked if $n$ is a
sink method. Rule 3.21 states that if there is any local variable in
method $m$ which is both tainted and untainted at some point in $m$,
then $m$ should be tracked. Rule 3.22 states that all methods not
tracked should be in the \texttt{untracked} predicate.

\section{Code Example} \label{ex}

\begin{figure}[H]
\begin{lstlisting}
  public class TaintTest {
    public int f;
    public static void main(String[] args) {
      TaintTest t = new TaintTest();
      t.run();
    }

    public void run() {
      String s = taintedString();
      foo(s);
    }

    public void foo(String s) {
      System.out.println(s);
    }

    public String taintedString() {
      return new String();
    }
    
    public void unreachable() {
      String s = taintedString();
      System.out.println(s);
    }
  }
\end{lstlisting}
\caption{Java code example}\label{fig:ex}
\end{figure}

The Java program in \ref{fig:ex} demonstrates how some of the
aforementioned Datalog rules apply to compute tainted data and tracked
methods. We will show the domain of methods filled by Petablox, a
relevant set of program facts generated by Petablox, and relevant
facts deduced by our rules.

\begin{figure}[H]
  \begin{lstlisting}[language=Prolog]
    "<java.io.PrintStream: void println(java.lang.String)>"
    "<TaintTest: java.lang.String taintedString()>"
    "<TaintTest: void main(java.lang.String[])>"
    "<TaintTest: void <init>()>"
    "<TaintTest: void run()>"
    "<TaintTest: void foo(java.lang.String)>"
  \end{lstlisting}
  \caption{Domain of methods for code in fig. \ref{fig:ex}}\label{fig:domM}
\end{figure}

Figure \ref{fig:domM} shows the domain of methods created by
Petablox. This domain contains all the methods reachable from the
program's main method. As such, the \texttt{unreachable} method is
absent from this domain. Petablox can be configured to compute
reachability either statically or dynamically.

\begin{figure}[H]
  \begin{lstlisting}[language=Prolog]
    taintSink("<java.io.PrintStream: void println(java.lang.String)>").
    taintSrc("<TaintTest: java.lang.String taintedString()>").

    IM("!0<TaintTest: void run()>",
       "<TaintTest: java.lang.String taintedString()>").
    IM("!1<TaintTest: void run()>",
       "<TaintTest: void foo(java.lang.String)>").
    
    IinvkXRet("!0<TaintTest: void run()>", 0,
              "java.lang.String s in <TaintTest: void run()>").
    IinvkXArg("!1<TaintTest: void run()>", 1,
              "java.lang.String s in <TaintTest: void run()>").

    MmethXArg("<TaintTest: void foo(java.lang.String)>", 1,
              "java.lang.String s in <TaintTest: void foo(java.lang.String)>").

    MM("<TaintTest: void foo(java.lang.String()>",
       "<java.io.PrintStream: void println(java.lang.String)>").
  \end{lstlisting}
  \caption{Relevant program fact base for code in fig. \ref{fig:ex}}\label{fig:facts}
\end{figure}

Figure \ref{fig:facts} shows relevant program facts for the code in
figure \ref{fig:ex}. The \texttt{taintSink} and \texttt{taintSrc}
facts show that specific methods are sink and source methods,
respectively. The \texttt{IM} facts show that the 0th and 1st call
sites in the \texttt{run} method resolve to the methods
\texttt{taintedString} and \texttt{foo}, respectively. The
\texttt{IinvkXRet} and \texttt{IinvkXArg} facts show that the return
variable of the 0th call site and the argument passed to the 1st call
site, respectively, are both the same local variable \texttt{s} in the
\texttt{run} method. The \texttt{MmethXArg} fact shows that the
parameter of the \texttt{foo} method is the local variable in
\texttt{foo} named \texttt{s}. Finally, the \texttt{MM} fact shows
that the \texttt{foo} method calls the \texttt{println} method.

Now we will show certain computed facts and explain how they were
computed.

\begin{figure}[H]
  \begin{lstlisting}
    taintedX("java.lang.String s in <TaintTest: void run()>").
    taintedX("java.lang.String s in <TaintTest: void foo()>").
    tracked("<TaintTest: void foo(java.lang.String)>").
    untracked("<TaintTest: void run()>").
  \end{lstlisting}
  \caption{Sample of computed facts for code in fig. \ref{fig:ex}}\label{fig:sol}
\end{figure}

The first computed fact states that the local variable named \texttt{s} in the \texttt{run} method is tainted. This results from applying Rule 3.9. The \texttt{taintSrc}, \texttt{IinvkXRet}, and \texttt{IM} facts from figure \ref{fig:facts} imply that the variable is tainted. The second computed fact is computed similarly, applying Rule 3.10.

The \texttt{tracked} fact is computed by applying Rule 3.20. The method \texttt{foo} is tracked because it calls a sink method, namely \texttt{println}. The method \texttt{run} is untracked due to the application of Rule 3.22. Rule 3.21 does not apply to \texttt{run} because its only local variable is only tainted and never untainted. 
    
\section{Instrumented and Uninstrumented Call Sites}
In addition to considering some methods to be tracked and some
untracked, sometimes invocations to tracked methods do not pass in any
tainted data and do not need to call instrumented code. As such, we
can maintain an instrumented and an uninstrumented version of each
tracked method. When no arguments passed to an invocation are tainted
(that is, all of the arguments belong only to the \texttt{taintedX}
predicate and not the \texttt{untaintedX} predicate), the called
method can be the uninstrumented version.

The following are the Datalog rules that determine which method call
sites will call the instrumented version of a method and which will
call the uninstrumented version.
\begin{equation}
  \mathtt{inst(m,n) \is MI(m,i) \also IM(i,n) \also IinvkXArg(i,\_,x)
    \also taintedX(x) \also tracked(n).}
\end{equation}
\begin{equation}
  \begin{split}
    \mathtt{inst(m,n) \is} & \mathtt{MgetInstFldInstX(n,\_,\_,f) \also
      taintedF(f) \also} \\ & \mathtt{MI(m,i) \also IM(i,n) \also
      tracked(n).}
  \end{split}
\end{equation}
\begin{equation}
  \begin{split}
    \mathtt{inst(m,n) \is} & \mathtt{MgetStatFldInstX(n,\_,f) \also
      taintedF(f) \also} \\ & \mathtt{MI(m,i) \also IM(i,n) \also
      tracked(n).}
  \end{split}
\end{equation}
\begin{equation}
  \mathtt{uninst(m,n) \is !inst(m,n).}
\end{equation}

Rule 3.23 states that the invocation entity $i$ corresponding to the
call of method $n$ inside method $m$ will be the instrumented version
if any of the arguments passed to the invocation are tainted at any
point. Rule 3.24 states that the call site of $n$ in $m$ is
instrumented if $n$ loads from a tainted instance field. Rule 3.25
states the same as 3.24 but for static fields.

Rule 3.26 states that any invocation not instrumented should be
uninstrumented.

\section{Additions to Petablox}
Many modifications and additions to Petablox were necessary to enable
the above analysis. These modifications came in the form of new entity
domains and new relations, both written in Java. Some new relations
were created by using an existing relation as a template and modifying
necessary types.

The first large addition was a new domain for local variables that
included primitive typed locals. The existing domain for local
variables, domain V, only included reference type local variables. We
decided to add a domain that included primitive local variables
instead of modifying domain V to include primitives due to issues with
backwards compatibility. In addition to adding this new entity domain,
many existing relations had to be copied and modified to use the new
domain instead of the old reference-only domain. Many of the
predicates in the above rules that contain the character X as part of
the name are examples of these new relations.

Also, Petablox previously handled native methods in an unexpected
way. Petablox first removed the native modifier from all native
methods and turned them into abstract methods without bodies,
indistinguishable from other abstract methods. Then Petablox took a
few specifically enumerated native methods, including
\texttt{System.arraycopy} and added fake bodies to simulate the
behavior of these methods. \phosphor{} did not model taint propagation
across native call boundaries in the same way the simulated bodies
created by Petablox did. Therefore we had to modify how Petablox
looked at native methods to accurately model \phosphor{}'s
behavior. Petablox was made to not remove the native modifier from
native methods and native methods were added to a new \texttt{nativeM}
predicate.
\section{Modifications to \phosphor{}}
Modifications to \phosphor{} were required to allow it to make use of
the information generated by the analysis in this paper. We
coordinated with the original author of \phosphor{} to implement these
modifications. A feedback loop was established where the original
author would make changes to \phosphor{} and we would generate
analysis results or modify the analysis if necessary and send those
results back. The details of modifications made to \phosphor{} are not
described in this paper.
