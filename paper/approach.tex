\chapter{Approach and Implementation}
In this chapter we describe the approach taken for our analysis. We show how the analysis propagates taint through the program and how this more accurately models the behavior of Phosphor than previous work. The analysis is constructed as a series of Datalog program facts which build on existing facts and each other. Each program fact is defined as a logical conjunction of one or more program facts. We begin with the facts that describe taintedness in local variables and fields. We then describe facts that are concerned with how taint is propagated through native library calls. We then describe facts that determine which methods need to be tracked. We finally describe facts about which call sites of tracked methods will call instrumented versions of the callee and which will call uninstrumented versions. We also detail additions and modifications to Petablox that were required to enable the analysis. In addition to showing the Datalog facts that power the analysis, we also include annotated code examples to ease understanding.
\section{Tainted and Untainted Objects}
\subsection{Taint Predicates}
We begin by describing the predicates that represent tainted and untainted values. \texttt{taintedX} and \texttt{untaintedX} represent tainted and untainted local variables, respectively. The local variables can be of primitive and reference type. If a local variable appears in \texttt{taintedX}, then the variable contained tainted data at some point. The same is true of a variable appearing in \texttt{untaintedX}. We are not interested in whether a variable \em{ever} contains tainted or untainted data, but rather if it \em{always} contains tainted or untainted data. If the latter is true, then we do not have to track the data through a method, since we know that it will be tainted at the end if it is tainted at the beginning.

For this insight to work, we must make a fundamental simplification of how taint is tagged and tracked through the program. Originally, Phosphor maintained a 32-bit taint tag which described exactly how a variable had been tainted and the origin of its taint. If we do not plan to track taint propagation through some methods in which a variable is always tainted or always untainted, we must simplify the taint tag to be only a boolean value. The reason is that a variable may be always tainted in a method, but the exact details of its taint may change through that method. The 32-bit taint tag may change from one non-zero taint tag to another. Without tracking taint propagation through that method, we are not able to track that change in taint detail. The most we can know is if a variable is tainted at the beginning of a method and it is always tainted during the method, it will be tainted at the end of the method.

The predicates \texttt{taintedF} and \texttt{untaintedF} represent tainted and untainted fields in the same manner as local variables.
\subsection{Assignment Rules}
assignment
\subsection{Return Rules}
returns

returns from sources
\subsection{Argument Rules}
arguments
\subsection{Constants and New Object Rules}
constants and new
\section{Native Code}
tainted - non system.arraycopy

tainted - system.arraycopy
\section{Tracked and Untracked Methods}
tracked(m)

calls into sinks

untracked(m)
\section{Instrumented and Uninstrumented Call Sites}
inst(m,n)

tainted args, field loads

uninst(m,n)
\section{Additions and Modifications to Petablox}
Petablox schema incomplete

Native methods

Primitives and constants
