\chapter{Introduction}

Dynamic taint tracking, also called dynamic information flow analysis,
is the technique of automatically tracking the paths of certain pieces
of data through a program during runtime. As such, information about
the data can be discovered as it enters and exits the program, is
written to and read from, and affects other parts of the
program. Taint tracking is useful for both determining the origin of a
piece of data as well as knowing information about its state during
program execution. Data is tagged as it enters the program through
user input or some other method, and tags are propagated as data is
operated on or combined with other data. The method of tag propagation
may vary but must be done in a way that the origins of a piece of data
are discoverable by inspecting the tag.

Plenty of motivation exists for taint tracking, including the
canonical example of detecting injection attacks such as SQL
injections. Tracking data such as user input can prevent injection of
potentially malicious data into critical functions or SQL command
processing methods \cite{sql1} \cite{sql2}. Many solutions and systems
exist, all with varous limitations. \cite{stringtaint} and \cite{sql1}
both modify programs at the bytecode level but only track data flow of
String-type objects. \cite{jikes} can track data flow of all Java
types but only targets an incomplete ``research JVM'' (read: not
Oracle or OpenJDK).  Most taint tracking systems suffer from bad
performance, soundness, precision, portability, or some combination of
the four.

Phosphor \cite{phosphor_oopsla} is a taint tracking system for the
Java Virtual Machine (JVM). It differs fundamentally from prior work
in how it stores and propagates taint tags and is able to be
performant, sound, precise, and portable. Phosphor does not require
any JVM modification and achieves taint tracking through instrumenting
program bytecode. Unlike previous approaches, Phosphor stores taint
tags as shadow variables, one for each concrete variable in the
program. Runtime operations cause modification and combination of
taint tags. For example, the resulting taint tag of an arithmetic
operation is the bitwise OR of the taint tags of the operands. Aside
from its portability, soundness, and precision achievements, Phosphor
introduces, on average, a 53\% performance overhead. Phosphor's main
mode of usage is to provide source and sink files, which enumerate the
methods from which data of interest originates and methods into which
we want to know if tainted data enters.

For simplicity and completeness, Phosphor instruments the entire
application bytecode and assumes the presence of an instrumented
JVM. The key insight of prior work done in \cite{manoj_project} is
that only a subset of the methods in the program callgraph needs to be
instrumented. Methods that do not lie on any of the paths from any
source to any sink are of no interest and can remain
uninstrumented. This work involved modifying Phosphor to support
partial instrumentation and performing static analysis to generate the
list of methods to be instrumented. This approach is able to save, on
average, 11\% of performance overhead compared to Phosphor.

However, this prior work fails to consider some program behaviors,
such as calls into native libraries. We describe a different taint
analysis for partial instrumentation that more completely and
accurately models the taint tracking done by Phosphor, including calls
to native libraries. Our approach also further reduces
instrumentation. By making a key assumption about taint tags we are
able to remove instrumentation on certain methods even if we know that
tainted data passes through them. The analysis described in this paper
is designed to integrate with further modifications made to Phosphor
by its original author.

The remainder of the thesis is as follows. Chapter 2 presents
background information on relevant tools and prior work. Chapter 3
presents the high-level approach taken to achieve partial
instrumentation. Chapter 4 describes the implementation details behind
achieving partial instrumentation. Chapter 5 shares results of the
implemented approach. Chapter 6 concludes the thesis.
